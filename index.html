<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Harvey Chandler</title>
  <meta name="description" content="Harvey Chandler — Computer Science student building clean internal tools, APIs, and automations." />

    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                    animation: {
                        'blob': 'blob 7s infinite',
                    },
                    keyframes: {
                        blob: {
                            '0%': { transform: 'translate(0px, 0px) scale(1)' },
                            '33%': { transform: 'translate(30px, -50px) scale(1.1)' },
                            '66%': { transform: 'translate(-20px, 20px) scale(0.9)' },
                            '100%': { transform: 'translate(0px, 0px) scale(1)' },
                        }
                    }
                }
            },
            plugins: [
                function({ addUtilities }) {
                    const newUtilities = {
                        '.animation-delay-2000': {
                            'animation-delay': '2s',
                        },
                        '.animation-delay-4000': {
                            'animation-delay': '4s',
                        },
                    }
                    addUtilities(newUtilities)
                }
            ]
        }
    </script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .bg-grid {
            background-size: 40px 40px;
            background-image: linear-gradient(to right, rgba(0,0,0,0.05) 1px, transparent 1px),
                              linear-gradient(to bottom, rgba(0,0,0,0.05) 1px, transparent 1px);
        }
        .dark .bg-grid {
            background-image: linear-gradient(to right, rgba(255,255,255,0.05) 1px, transparent 1px),
                              linear-gradient(to bottom, rgba(255,255,255,0.05) 1px, transparent 1px);
        }
        
        /* Typing Effect Cursor */
        .typing-cursor::after {
            content: '|';
            animation: blink 1s step-start infinite;
            color: #7c8cff; /* Accent color */
        }
        @keyframes blink {
            50% { opacity: 0; }
        }
        
        /* Hide elements before typing/reveal */
        .type-this { visibility: hidden; }
        .reveal-on-scroll { opacity: 0; transform: translateY(20px); transition: all 0.6s ease-out; }
        .reveal-visible { opacity: 1; transform: translateY(0); }
    </style>
</head>
<body class="bg-white dark:bg-[#0d1117] text-zinc-900 dark:text-zinc-100 transition-colors duration-300 min-h-screen flex flex-col relative overflow-x-hidden select-none">

    <!-- Background Effects -->
    <canvas id="bg-canvas" class="fixed inset-0 -z-10"></canvas>

    <div class="max-w-3xl mx-auto w-full my-0 sm:my-12 p-6 sm:p-10 bg-white/70 dark:bg-zinc-950/70 backdrop-blur-md rounded-none sm:rounded-3xl shadow-2xl border-x-0 sm:border border-zinc-200/50 dark:border-zinc-800/50 flex-grow relative z-10">
        
        <!-- Header -->
        <header class="flex justify-between items-center mb-8 sm:mb-20">
            <a href="#" class="font-semibold text-lg tracking-tight hover:text-zinc-600 dark:hover:text-zinc-300 transition-colors">
                Harvey Chandler<span class="text-zinc-400 dark:text-zinc-600">.me</span>
            </a>
            <div class="flex items-center gap-6 text-sm font-medium text-zinc-600 dark:text-zinc-400">
                <nav class="hidden sm:flex gap-6">
                    <a href="#projects" class="hover:text-black dark:hover:text-white transition-colors">Projects</a>
                    <a href="#about" class="hover:text-black dark:hover:text-white transition-colors">About</a>
                </nav>
                <button id="game-mode-toggle" class="hidden sm:block p-2 rounded-full hover:bg-zinc-100 dark:hover:bg-zinc-800 transition-colors" aria-label="Toggle Game Mode" title="Take Control">
                    <!-- Controller Icon (Show when in AI mode) -->
                    <svg id="icon-controller" class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 5v2m0 4v2m0 4v2M5 5a2 2 0 00-2 2v3a2 2 0 110 4v3a2 2 0 002 2h14a2 2 0 002-2v-3a2 2 0 110-4V7a2 2 0 00-2-2H5z"></path>
                    </svg>
                    <!-- Robot Icon (Show when in Manual mode) -->
                    <svg id="icon-robot" class="w-5 h-5 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"></path>
                    </svg>
                </button>
                <button id="theme-toggle" class="p-2 rounded-full hover:bg-zinc-100 dark:hover:bg-zinc-800 transition-colors" aria-label="Toggle Dark Mode">
                    <!-- Sun Icon -->
                    <svg class="w-5 h-5 hidden dark:block" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path></svg>
                    <!-- Moon Icon -->
                    <svg class="w-5 h-5 block dark:hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path></svg>
                </button>
            </div>
        </header>

        <!-- Hero -->
        <main>
            <section class="mb-24">
                <h1 id="hero-title" class="text-4xl sm:text-5xl font-bold tracking-tight mb-8 text-zinc-900 dark:text-white min-h-[2.4em] sm:min-h-[1.2em]">
                    
                </h1>
                
                <div class="flex flex-col md:flex-row gap-8 items-center mb-10 reveal-on-scroll">
                    <div class="space-y-6 flex-1">
                        <div id="exeter-card" class="flex items-center gap-4 p-2 -ml-2 rounded-xl hover:bg-zinc-50 dark:hover:bg-zinc-800/50 transition-colors cursor-default">
                            <div class="w-12 h-12 rounded-xl bg-white dark:bg-zinc-800 border border-zinc-200 dark:border-zinc-700 shadow-sm overflow-hidden">
                                <img src="https://avatars.githubusercontent.com/u/73302932?s=280&v=4" alt="University of Exeter" class="w-full h-full object-cover">
                            </div>
                            <div>
                                <h3 class="font-semibold text-zinc-900 dark:text-white">Computer Science Student</h3>
                                <p class="text-sm text-zinc-500 dark:text-zinc-400">University of Exeter <span class="mx-1 opacity-50">•</span> Full Time</p>
                            </div>
                        </div>
                        <div id="gigaclear-card" class="flex items-center gap-4 p-2 -ml-2 rounded-xl hover:bg-zinc-50 dark:hover:bg-zinc-800/50 transition-colors cursor-default">
                            <div class="w-12 h-12 rounded-xl bg-white dark:bg-zinc-800 border border-zinc-200 dark:border-zinc-700 shadow-sm overflow-hidden">
                                <img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQsJpRtPBb-7xR1cLbbJMfPRYMK6U4DUzw7yA&s" alt="Gigaclear" class="w-full h-full object-cover">
                            </div>
                            <div>
                                <h3 class="font-semibold text-zinc-900 dark:text-white">Productivity Analyst</h3>
                                <p class="text-sm text-zinc-500 dark:text-zinc-400">Gigaclear <span class="mx-1 opacity-50">•</span> Part Time</p>
                            </div>
                        </div>
                    </div>
                    <div class="flex-shrink-0 w-full sm:w-auto flex justify-center">
                        <img id="me-photo" src="./me2.png" alt="Harvey Chandler" class="w-[80%] aspect-square rounded-2xl sm:w-32 sm:h-32 md:w-40 md:h-40 sm:rounded-full object-cover border-2 border-zinc-200 dark:border-zinc-700 shadow-md cursor-pointer hover:scale-105 transition-transform">
                    </div>
                </div>

                <div class="flex gap-4 reveal-on-scroll">
                    <a id="contact-btn" href="mailto:harveychandler235@gmail.com" class="inline-flex items-center justify-center px-5 py-2.5 text-sm font-medium rounded-lg bg-zinc-900 text-white hover:bg-zinc-700 dark:bg-white dark:text-zinc-900 dark:hover:bg-zinc-200 transition-colors">
                        Contact Me
                    </a>
                    <a id="linkedin-btn" href="https://www.linkedin.com/in/harveychandler/" target="_blank" class="inline-flex items-center justify-center px-5 py-2.5 text-sm font-medium rounded-lg border border-zinc-200 dark:border-zinc-700 hover:bg-zinc-50 dark:hover:bg-zinc-800 transition-colors">
                        LinkedIn
                    </a>
                </div>
            </section>

            <!-- Projects -->
            <section id="projects" class="mb-24 reveal-on-scroll">
                <h2 class="text-xl font-semibold mb-8 text-zinc-900 dark:text-white">Selected Projects</h2>
                <div class="grid gap-4 sm:gap-8 sm:grid-cols-2">
                    <div class="group">
                        <h3 class="font-medium text-zinc-900 dark:text-white mb-2 group-hover:text-blue-600 dark:group-hover:text-blue-400 transition-colors">
                            <a href="https://chromewebstore.google.com/detail/panopto-custom-speed/fnoppdfnaklabgfllejlefomclegmnam" target="_blank">Panopto Custom Speed</a>
                        </h3>
                        <p class="text-sm text-zinc-600 dark:text-zinc-400 leading-relaxed mb-3">
                            Chrome extension allowing custom playback speeds for Panopto videos.
                        </p>
                        <div class="flex gap-2">
                            <img src="https://img.shields.io/chrome-web-store/users/fnoppdfnaklabgfllejlefomclegmnam?style=flat-square&color=2563eb&labelColor=e4e4e7" alt="Users" class="h-5">
                            <img src="https://img.shields.io/chrome-web-store/stars/fnoppdfnaklabgfllejlefomclegmnam?style=flat-square&color=2563eb&labelColor=e4e4e7" alt="Stars" class="h-5">
                        </div>
                    </div>
                    <div class="group">
                        <h3 class="font-medium text-zinc-900 dark:text-white mb-2 group-hover:text-blue-600 dark:group-hover:text-blue-400 transition-colors">Salesforce Automation</h3>
                        <p class="text-sm text-zinc-600 dark:text-zinc-400 leading-relaxed mb-3">
                            Automating events within Salesforce and connecting data with custom built apps to help visualise the data.
                        </p>
                        <!-- <div class="flex items-center gap-2">
                            <img src="https://img.shields.io/badge/JavaScript-F7DF1E?style=flat-square" alt="JavaScript" class="h-5">
                        </div> -->
                    </div>
                    <div class="group">
                        <h3 class="font-medium text-zinc-900 dark:text-white mb-2 group-hover:text-blue-600 dark:group-hover:text-blue-400 transition-colors">Mapping Software</h3>
                        <p class="text-sm text-zinc-600 dark:text-zinc-400 leading-relaxed mb-3">
                            Utilising live and static data to create mapping software for field engineers and planning teams.
                        </p>
                        <div class="flex items-center gap-2">
                            <img src="https://img.shields.io/badge/PostgreSQL-316192?style=flat-square&logo=postgresql&logoColor=white" alt="PostgreSQL" class="h-5">
                            <img src="https://img.shields.io/badge/WebSockets-000000?style=flat-square&logo=socket.io&logoColor=white" alt="WebSockets" class="h-5">
                        </div>
                    </div>
                    <!-- <div class="group">
                        <h3 class="font-medium text-zinc-900 dark:text-white mb-2 group-hover:text-blue-600 dark:group-hover:text-blue-400 transition-colors">Internal Tooling API</h3>
                        <p class="text-sm text-zinc-600 dark:text-zinc-400 leading-relaxed">
                            Node.js services designed to standardise internal processes and data flows.
                        </p>
                    </div> -->
                </div>
            </section>

            <!-- About / Skills -->
            <section id="about" class="mb-24 reveal-on-scroll">
                <h2 class="text-xl font-semibold mb-8 text-zinc-900 dark:text-white">About</h2>
                <div class="flex flex-col md:flex-row gap-8 items-center md:items-start">
                    <div class="prose dark:prose-invert text-zinc-600 dark:text-zinc-400 text-sm leading-relaxed max-w-none flex-1">
                        <p class="mb-6">
                            I'm currently studying Computer Science at the University of Exeter while working part-time. I'm interested in full-stack development, automation, and building efficient systems.<br><br>Notably, I also achieved a grade A in Physics and Maths at A Level.
                        </p>
                        <p class="mb-6">
                            I am currently seeking a Software Engineering placement year.
                        </p>
                        
                        <div class="flex flex-wrap gap-2 mt-8">
                            <span class="px-3 py-1 bg-zinc-100 dark:bg-zinc-800 rounded-full text-xs font-medium">JavaScript</span>
                            <span class="px-3 py-1 bg-zinc-100 dark:bg-zinc-800 rounded-full text-xs font-medium">Python</span>
                            <span class="px-3 py-1 bg-zinc-100 dark:bg-zinc-800 rounded-full text-xs font-medium">SQL</span>
                            <span class="px-3 py-1 bg-zinc-100 dark:bg-zinc-800 rounded-full text-xs font-medium">Node.js</span>
                            <span class="px-3 py-1 bg-zinc-100 dark:bg-zinc-800 rounded-full text-xs font-medium">AWS</span>
                            <span class="px-3 py-1 bg-zinc-100 dark:bg-zinc-800 rounded-full text-xs font-medium">React</span>
                        </div>
                    </div>
                    <div class="flex-shrink-0 w-full sm:w-auto flex justify-center">
                        <img src="https://avatars.githubusercontent.com/u/212951?v=4" alt="Harvey Chandler" class="w-[80%] aspect-square rounded-2xl sm:w-32 sm:h-32 md:w-40 md:h-40 sm:rounded-full object-cover border-2 border-zinc-200 dark:border-zinc-700 shadow-md">
                    </div>
                </div>
            </section>
        </main>

        <footer class="pt-8 border-t border-zinc-200 dark:border-zinc-800 flex justify-between items-center text-xs text-zinc-500 dark:text-zinc-500 reveal-on-scroll">
            <span>&copy; <span id="year"></span> Harvey Chandler</span>
            <div class="flex gap-4">
                <a href="mailto:youremail@example.com" class="hover:text-zinc-900 dark:hover:text-zinc-300 transition-colors">Email</a>
                <a href="https://github.com/harvey" class="hover:text-zinc-900 dark:hover:text-zinc-300 transition-colors">GitHub</a>
            </div>
        </footer>

    </div>

    <script>
        // Year
        document.getElementById('year').textContent = new Date().getFullYear();

        // Dark Mode Logic
        const themeToggleBtn = document.getElementById('theme-toggle');
        const htmlElement = document.documentElement;

        // Check local storage or system preference
        if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
            htmlElement.classList.add('dark');
        } else {
            htmlElement.classList.remove('dark');
        }

        themeToggleBtn.addEventListener('click', () => {
            if (htmlElement.classList.contains('dark')) {
                htmlElement.classList.remove('dark');
                localStorage.theme = 'light';
            } else {
                htmlElement.classList.add('dark');
                localStorage.theme = 'dark';
            }
        });

        // Typing Effect Logic
        const heroTitle = document.getElementById('hero-title');
        const exeterCard = document.getElementById('exeter-card');
        const gigaclearCard = document.getElementById('gigaclear-card');
        const mePhoto = document.getElementById('me-photo');
        const contactBtn = document.getElementById('contact-btn');
        const linkedinBtn = document.getElementById('linkedin-btn');
        
        let script = [
            { text: "Software Developer.", wait: 2000 },
            { text: "Computer Science Student.", wait: 3000 },
            { text: "Productivity Analyst.", wait: 3000 },
            { text: "Software Developer.", wait: 0 },
        ];
        
        let scriptIndex = 0;
        let isScriptActive = true;
        let targetPhrase = "";
        let isWaiting = false;
        let typeTimeout = null;

        function updateTypewriter() {
            const current = heroTitle.textContent;
            let target = isScriptActive ? script[scriptIndex].text : targetPhrase;
            
            // If waiting, do nothing (the timeout will call us back)
            if (isWaiting) return;

            if (current === target) {
                // If we are in a script sequence, trigger the wait
                if (isScriptActive) {
                    isWaiting = true;
                    setTimeout(() => {
                        isWaiting = false;
                        scriptIndex++;
                        if (scriptIndex >= script.length) {
                            isScriptActive = false; // End of script
                            targetPhrase = current; // Stay on last phrase
                        }
                        updateTypewriter();
                    }, script[scriptIndex].wait); // Use the wait time of the CURRENT phrase
                }
                return;
            }

            // Determine action
            let delay = 100;

            if (current.length > target.length || !target.startsWith(current)) {
                // Backspace
                heroTitle.textContent = current.substring(0, current.length - 1);
                delay = 50;
            } else {
                // Type
                heroTitle.textContent = target.substring(0, current.length + 1);
                delay = 100 + Math.random() * 30; // Slight variation
            }

            typeTimeout = setTimeout(updateTypewriter, delay);
        }

        // Interactive Hover Logic
        function interruptTyping(newTarget) {
            isScriptActive = false;
            targetPhrase = newTarget;
            isWaiting = false; // Cancel any wait
            
            // Cancel pending type loop to restart immediately with new target
            if (typeTimeout) clearTimeout(typeTimeout);
            updateTypewriter();
        }

        if (exeterCard) {
            exeterCard.addEventListener('mouseenter', () => interruptTyping("Computer Science Student."));
            exeterCard.addEventListener('mouseleave', () => interruptTyping("Software Developer."));
        }
        if (gigaclearCard) {
            gigaclearCard.addEventListener('mouseenter', () => interruptTyping("Productivity Analyst."));
            gigaclearCard.addEventListener('mouseleave', () => interruptTyping("Software Developer."));
        }
        if (mePhoto) {
            mePhoto.addEventListener('mouseenter', () => interruptTyping("That is me :)"));
            mePhoto.addEventListener('mouseleave', () => interruptTyping("Software Developer."));
        }
        if (contactBtn) {
            contactBtn.addEventListener('mouseenter', () => interruptTyping("Send me an email?"));
            contactBtn.addEventListener('mouseleave', () => interruptTyping("Software Developer."));
        }
        if (linkedinBtn) {
            let linkedinTimeout;
            linkedinBtn.addEventListener('mouseenter', () => {
                interruptTyping("Connect with me!");
                linkedinTimeout = setTimeout(() => {
                    interruptTyping("Connect with me!!!!");
                }, 5000);
            });
            linkedinBtn.addEventListener('mouseleave', () => {
                clearTimeout(linkedinTimeout);
                interruptTyping("Software Developer.");
            });
        }

        // Start typing when page loads
        window.addEventListener('load', () => {
            heroTitle.classList.add('typing-cursor');
            updateTypewriter();
            
            // Reveal other elements
            const revealElements = document.querySelectorAll('.reveal-on-scroll');
            revealElements.forEach((el, index) => {
                setTimeout(() => {
                    el.classList.add('reveal-visible');
                }, index * 200);
            });
            
            initBackground();
        });

        // GitHub Contribution Graph Background with Snake
        function initBackground() {
            const canvas = document.getElementById('bg-canvas');
            const ctx = canvas.getContext('2d');
            const container = document.querySelector('.max-w-3xl');
            
            let width, height;
            const squareSize = 12;
            const gap = 4;
            const totalSize = squareSize + gap;
            
            // Colors
            const colors = {
                dark: ['#161b22', '#0e4429', '#006d32', '#26a641', '#39d353'],
                light: ['#ebedf0', '#9be9a8', '#40c463', '#30a14e', '#216e39']
            };

            let grid = [];
            let cols, rows;
            let isAiMode = true;

            // Snake State
            const snake = {
                body: [],
                dir: {x: 1, y: 0},
                nextDir: {x: 1, y: 0},
                inputQueue: [],
                stepTime: 50,
                lastStep: 0,
                target: null,
                growing: 0
            };

            // Drawing Interaction
            let isDrawing = false;
            let lastPaintedCell = null;

            window.addEventListener('mousedown', (e) => {
                // Only start drawing if left click
                if (e.button === 0) {
                    isDrawing = true;
                    paint(e.clientX, e.clientY);
                }
            });

            window.addEventListener('mousemove', (e) => {
                if (isDrawing) {
                    paint(e.clientX, e.clientY);
                }
            });

            window.addEventListener('mouseup', () => {
                isDrawing = false;
                lastPaintedCell = null;
            });

            function paint(x, y) {
                if (!grid || !grid.length) return;
                
                const i = Math.floor(x / totalSize);
                const j = Math.floor(y / totalSize);

                if (i >= 0 && i < cols && j >= 0 && j < rows) {
                    // Avoid incrementing the same cell multiple times in one drag if we haven't left it
                    if (!lastPaintedCell || lastPaintedCell.x !== i || lastPaintedCell.y !== j) {
                        if (grid[i] && grid[i][j] !== undefined && grid[i][j] < 4) {
                            grid[i][j]++;
                            drawCell(i, j, grid[i][j]); // Update offscreen canvas
                            // Force a redraw immediately for responsiveness
                            requestAnimationFrame(draw);
                        }
                        lastPaintedCell = {x: i, y: j};
                    }
                }
            }

            // Game Mode Toggle
            const modeToggleBtn = document.getElementById('game-mode-toggle');
            const iconController = document.getElementById('icon-controller');
            const iconRobot = document.getElementById('icon-robot');

            modeToggleBtn.addEventListener('click', () => {
                isAiMode = !isAiMode;
                if (isAiMode) {
                    iconController.classList.remove('hidden');
                    iconRobot.classList.add('hidden');
                    modeToggleBtn.title = "Take Control";
                } else {
                    iconController.classList.add('hidden');
                    iconRobot.classList.remove('hidden');
                    modeToggleBtn.title = "Let AI Play";
                    // Reset snake to center to give user a fair start
                    initGrid();
                }
            });

            // Manual Control
            window.addEventListener('keydown', (e) => {
                if (isAiMode) return;
                
                const key = e.key;
                let newDir = null;
                
                if (key === 'ArrowUp' || key === 'w') newDir = {x: 0, y: -1};
                if (key === 'ArrowDown' || key === 's') newDir = {x: 0, y: 1};
                if (key === 'ArrowLeft' || key === 'a') newDir = {x: -1, y: 0};
                if (key === 'ArrowRight' || key === 'd') newDir = {x: 1, y: 0};
                
                if (newDir) {
                    // Determine the last planned direction
                    const lastDir = snake.inputQueue.length > 0 
                        ? snake.inputQueue[snake.inputQueue.length - 1] 
                        : snake.nextDir;

                    // Prevent 180 degree turns relative to the last planned direction
                    if (newDir.x !== -lastDir.x && newDir.y !== -lastDir.y) {
                        // Limit buffer size to 2
                        if (snake.inputQueue.length < 2) {
                            snake.inputQueue.push(newDir);
                        }
                    }
                }
            });

            // Offscreen Canvas for static grid
            let bgCanvas = document.createElement('canvas');
            let bgCtx = bgCanvas.getContext('2d', { alpha: true });

            function resize() {
                width = canvas.width = window.innerWidth;
                height = canvas.height = window.innerHeight;
                
                bgCanvas.width = width;
                bgCanvas.height = height;
                
                cols = Math.ceil(width / totalSize);
                rows = Math.ceil(height / totalSize);
                initGrid();
            }

            function drawCell(i, j, colorIndex) {
                const isDark = htmlElement.classList.contains('dark');
                const palette = isDark ? colors.dark : colors.light;
                
                const x = i * totalSize;
                const y = j * totalSize;
                
                // Clear the cell area first (important for transparency)
                bgCtx.clearRect(x, y, totalSize, totalSize);
                
                bgCtx.fillStyle = palette[colorIndex];
                bgCtx.beginPath();
                if (bgCtx.roundRect) {
                    bgCtx.roundRect(x, y, squareSize, squareSize, 2);
                } else {
                    bgCtx.rect(x, y, squareSize, squareSize);
                }
                bgCtx.fill();
            }

            function renderFullGrid() {
                bgCtx.clearRect(0, 0, width, height);
                for (let i = 0; i < cols; i++) {
                    for (let j = 0; j < rows; j++) {
                        drawCell(i, j, grid[i][j]);
                    }
                }
            }

            function initGrid() {
                grid = [];
                const rect = container.getBoundingClientRect();
                
                for (let i = 0; i < cols; i++) {
                    grid[i] = [];
                    for (let j = 0; j < rows; j++) {
                        const x = i * totalSize;
                        const y = j * totalSize;
                        
                        let colorIndex = 0;
                        
                        const rand = Math.random();
                        if (rand > 0.92) colorIndex = 4;
                        else if (rand > 0.84) colorIndex = 3;
                        else if (rand > 0.75) colorIndex = 2;
                        else if (rand > 0.6) colorIndex = 1;
                        
                        grid[i][j] = colorIndex;
                    }
                }
                
                renderFullGrid();
                
                // Reset snake
                const startX = Math.floor(cols/2);
                const startY = Math.floor(rows/2);
                snake.body = [];
                for(let k=0; k<8; k++) {
                    snake.body.push({x: startX, y: startY});
                }
                snake.dir = {x: 1, y: 0};
                snake.nextDir = {x: 1, y: 0};
                snake.inputQueue = [];
                snake.target = null;
                snake.growing = 0;
            }

            function getDist(p1, p2) {
                const dx = Math.abs(p1.x - p2.x);
                const dy = Math.abs(p1.y - p2.y);
                // Consider wrapping in distance
                const wx = Math.min(dx, cols - dx);
                const wy = Math.min(dy, rows - dy);
                return wx + wy;
            }

            function findTarget() {
                const head = snake.body[0];
                let minDist = Infinity;
                let target = null;
                
                for (let i = 0; i < cols; i++) {
                    for (let j = 0; j < rows; j++) {
                        if (grid[i][j] > 0) {
                            const dist = getDist(head, {x: i, y: j});
                            if (dist < minDist) {
                                minDist = dist;
                                target = {x: i, y: j};
                            }
                        }
                    }
                }
                return target;
            }

            function update(timestamp) {
                if (timestamp - snake.lastStep < snake.stepTime) {
                    requestAnimationFrame(update);
                    return;
                }
                snake.lastStep = timestamp;

                const head = snake.body[0];
                
                // AI Logic
                if (isAiMode) {
                    if (!snake.target || grid[snake.target.x][snake.target.y] === 0) {
                        snake.target = findTarget();
                    }
                    
                    if (snake.target) {
                        // Improved Pathfinding with Wrapping
                        const t = snake.target;
                        const moves = [
                            {x:0, y:-1}, {x:0, y:1}, {x:-1, y:0}, {x:1, y:0}
                        ];
                        
                        // Filter reverse and self-collision
                        const validMoves = moves.filter(m => {
                            // No reverse
                            if (m.x === -snake.dir.x && m.y === -snake.dir.y) return false;
                            
                            // Check collision
                            const nextPos = {
                                x: (head.x + m.x + cols) % cols,
                                y: (head.y + m.y + rows) % rows
                            };
                            
                            // Check if nextPos is in body
                            return !snake.body.some(segment => segment.x === nextPos.x && segment.y === nextPos.y);
                        });
                        
                        // Sort by distance
                        validMoves.sort((a, b) => {
                            const posA = {
                                x: (head.x + a.x + cols) % cols,
                                y: (head.y + a.y + rows) % rows
                            };
                            const posB = {
                                x: (head.x + b.x + cols) % cols,
                                y: (head.y + b.y + rows) % rows
                            };
                            return getDist(posA, t) - getDist(posB, t);
                        });
                        
                        if (validMoves.length > 0) {
                            snake.nextDir = validMoves[0];
                        }
                    } else {
                        // Wander
                        if (Math.random() < 0.05) {
                            const dirs = [{x:1, y:0}, {x:-1, y:0}, {x:0, y:1}, {x:0, y:-1}];
                            // Filter valid wander moves
                            const validDirs = dirs.filter(d => {
                                if (d.x === -snake.dir.x && d.y === -snake.dir.y) return false;
                                const nextPos = {
                                    x: (head.x + d.x + cols) % cols,
                                    y: (head.y + d.y + rows) % rows
                                };
                                return !snake.body.some(segment => segment.x === nextPos.x && segment.y === nextPos.y);
                            });
                            
                            if (validDirs.length > 0) {
                                snake.nextDir = validDirs[Math.floor(Math.random() * validDirs.length)];
                            }
                        }
                    }
                }

                // Manual Mode: Process Input Queue
                if (!isAiMode && snake.inputQueue.length > 0) {
                    snake.nextDir = snake.inputQueue.shift();
                }
                
                snake.dir = snake.nextDir;
                
                let newHead = {
                    x: (head.x + snake.dir.x + cols) % cols,
                    y: (head.y + snake.dir.y + rows) % rows
                };
                
                // Check for collision (Game Over)
                if (snake.body.some(segment => segment.x === newHead.x && segment.y === newHead.y)) {
                    initGrid(); // Reset game
                    requestAnimationFrame(update);
                    return;
                }
                
                snake.body.unshift(newHead);
                
                // Eat logic
                if (grid[newHead.x][newHead.y] > 0) {
                    grid[newHead.x][newHead.y] = 0;
                    drawCell(newHead.x, newHead.y, 0); // Update offscreen canvas
                }
                
                snake.body.pop();
                
                draw();
                requestAnimationFrame(update);
            }

            function draw() {
                const isDark = htmlElement.classList.contains('dark');
                const palette = isDark ? colors.dark : colors.light;
                const snakeColor = '#a855f7'; // Purple
                
                ctx.clearRect(0, 0, width, height);
                
                // Draw Grid from offscreen canvas
                ctx.drawImage(bgCanvas, 0, 0);
                
                // Draw Snake (Fluid Shape)
                ctx.fillStyle = snakeColor;
                ctx.strokeStyle = snakeColor;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                // Draw connections first
                ctx.beginPath();
                for (let i = 0; i < snake.body.length - 1; i++) {
                    const curr = snake.body[i];
                    const next = snake.body[i+1];
                    
                    // Don't draw across screen wrap
                    if (Math.abs(curr.x - next.x) > 1 || Math.abs(curr.y - next.y) > 1) continue;
                    
                    const x1 = curr.x * totalSize + squareSize/2;
                    const y1 = curr.y * totalSize + squareSize/2;
                    const x2 = next.x * totalSize + squareSize/2;
                    const y2 = next.y * totalSize + squareSize/2;
                    
                    // Tapering thickness
                    const progress = i / (snake.body.length - 1);
                    const thickness = squareSize * (1.2 - 0.4 * progress); // 1.2x to 0.8x
                    
                    ctx.lineWidth = thickness;
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                }
                
                // Draw joints/circles to smooth it out
                for (let i = 0; i < snake.body.length; i++) {
                    const segment = snake.body[i];
                    const x = segment.x * totalSize + squareSize/2;
                    const y = segment.y * totalSize + squareSize/2;
                    
                    const progress = i / (snake.body.length - 1 || 1);
                    const size = squareSize * (1.2 - 0.4 * progress);
                    
                    ctx.beginPath();
                    ctx.arc(x, y, size/2, 0, Math.PI*2);
                    ctx.fill();
                }
            }
            
            window.addEventListener('resize', resize);
            
            // Redraw when theme changes
            const observer = new MutationObserver(() => {
                renderFullGrid();
                draw();
            });
            observer.observe(htmlElement, { attributes: true, attributeFilter: ['class'] });
            
            resize();
            requestAnimationFrame(update);
        }

    </script>
</body>
</html>